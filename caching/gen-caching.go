// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package caching

import (
	"context"
	"io/ioutil"
	"log"
	"os"

	"cloud.google.com/go/storage"
	aw "github.com/deanishe/awgo"
	"github.com/ishii1648/alfred-gcp-console-services-workflow/gcp"
	cloudresourcemanager "google.golang.org/api/cloudresourcemanager/v1"
	run "google.golang.org/api/run/v1"
	"google.golang.org/api/sqladmin/v1"
	containerpb "google.golang.org/genproto/googleapis/container/v1"
)

type ContainerpbClusterListFetcher = func(ctx context.Context, gcpProject string) ([]*containerpb.Cluster, error)

func LoadContainerpbClusterListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher ContainerpbClusterListFetcher, forceFetch bool, rawQuery string, gcpProject string) []*containerpb.Cluster {
	cacheName += "_" + gcpProject
	results := []*containerpb.Cluster{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return []*containerpb.Cluster{}
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}

type StorageBucketAttrsListFetcher = func(ctx context.Context, gcpProject string) ([]*storage.BucketAttrs, error)

func LoadStorageBucketAttrsListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher StorageBucketAttrsListFetcher, forceFetch bool, rawQuery string, gcpProject string) []*storage.BucketAttrs {
	cacheName += "_" + gcpProject
	results := []*storage.BucketAttrs{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return []*storage.BucketAttrs{}
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}

type GcpPubsubSubscriptionListFetcher = func(ctx context.Context, gcpProject string) ([]*gcp.PubsubSubscription, error)

func LoadGcpPubsubSubscriptionListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher GcpPubsubSubscriptionListFetcher, forceFetch bool, rawQuery string, gcpProject string) []*gcp.PubsubSubscription {
	cacheName += "_" + gcpProject
	results := []*gcp.PubsubSubscription{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return []*gcp.PubsubSubscription{}
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}

type GcpPubsubTopicListFetcher = func(ctx context.Context, gcpProject string) ([]*gcp.PubsubTopic, error)

func LoadGcpPubsubTopicListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher GcpPubsubTopicListFetcher, forceFetch bool, rawQuery string, gcpProject string) []*gcp.PubsubTopic {
	cacheName += "_" + gcpProject
	results := []*gcp.PubsubTopic{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return []*gcp.PubsubTopic{}
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}

type RunServiceListFetcher = func(ctx context.Context, gcpProject string) ([]run.Service, error)

func LoadRunServiceListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher RunServiceListFetcher, forceFetch bool, rawQuery string, gcpProject string) []run.Service {
	cacheName += "_" + gcpProject
	results := []run.Service{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return []run.Service{}
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}

type CloudresourcemanagerProjectListFetcher = func(ctx context.Context, gcpProject string) ([]*cloudresourcemanager.Project, error)

func LoadCloudresourcemanagerProjectListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher CloudresourcemanagerProjectListFetcher, forceFetch bool, rawQuery string, gcpProject string) []*cloudresourcemanager.Project {
	cacheName += "_" + gcpProject
	results := []*cloudresourcemanager.Project{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return []*cloudresourcemanager.Project{}
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}

type CloudSQLInstanceListFetcher = func(ctx context.Context, gcpProject string) ([]*sqladmin.DatabaseInstance, error)

func LoadCloudSQLInstanceListFromCache(wf *aw.Workflow, ctx context.Context, cacheName string, fetcher CloudSQLInstanceListFetcher, forceFetch bool, rawQuery string, gcpProject string) []*sqladmin.DatabaseInstance {
	cacheName += "_" + gcpProject
	results := []*sqladmin.DatabaseInstance{}
	lastFetchErrPath := wf.CacheDir() + "/last-fetch-err.txt"

	if forceFetch {
		log.Printf("fetching from gcp ...")
		results, err := fetcher(ctx, gcpProject)

		if err != nil {
			log.Printf("fetch error occurred. writing to %s ...", lastFetchErrPath)
			ioutil.WriteFile(lastFetchErrPath, []byte(err.Error()), 0600)
			panic(err)
		} else {
			os.Remove(lastFetchErrPath)
		}

		log.Printf("storing %d results with cache key `%s` to %s ...", len(results), cacheName, wf.CacheDir())
		if err := wf.Cache.StoreJSON(cacheName, results); err != nil {
			panic(err)
		}

		return results
	}

	err := handleExpiredCache(wf, cacheName, lastFetchErrPath, rawQuery)
	if err != nil {
		return nil
	}

	if wf.Cache.Exists(cacheName) {
		log.Printf("using cache with key `%s` in %s ...", cacheName, wf.CacheDir())
		if err := wf.Cache.LoadJSON(cacheName, &results); err != nil {
			panic(err)
		}
	} else {
		log.Printf("cache with key `%s` did not exist in %s ...", cacheName, wf.CacheDir())
		wf.NewItem("Fetching ...").
			Icon(aw.IconInfo)
	}

	return results
}
